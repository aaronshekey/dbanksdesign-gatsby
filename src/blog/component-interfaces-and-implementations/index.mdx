---
title: 'Component Interfaces and Implementations'
date: '2019-04-21'
---

import Graph from "./Graph"
import Graphv2 from "./Graphv2"

In some traditional programming languages like Objective-C and Java, classes can have an **Interface** and an **Implementation**. For those familiar with Javascript and React, a class interface is similar to a type definition in TypeScript or a React component's PropTypes. A class interface is like an API contract to the user. The underlying implementation can change as long as the interface remains the same.

An interface in Java looks like this:

```java
public interface Person {
  private static String name;
  public void talk();
}
```

You could also think of it like an abstract class where you have to override all the methods and attributes. Either way it is the same, a construct to describe the API of a class. 

Then you can have any number of **implementations** of `Person`:

```java
public class Stan implements Person {
  private static String name = "Stan";

  public void talk() {
    System.out.print("Hello World");
  }
}
```

Now we can change the underlying implementation, `Stan`, as long as it still properly implements the interface, `Person`:

```java
public class Stan implements Person {
  private static String name = "Stanley";

  public void talk() {
    System.out.print("I'm Stan!");
  }
}
```

<hr />

#### What does this have to do with design systems and components?

This gets to what [Ysenia Perez-Cruz](https://twitter.com/yeseniaa) describes as [scenario driven components](https://www.clarityconf.com/session/scenario-driven-design-systems). The definition of the component is based on a scenario rather than a presentation. This could also be described as *semantic* versus *presentational* components. A semantic component clearly separates the *interface* from the *implementation* whereas a presentational one tightly couples them.

> Scenarios, not layout should drive variation.  
> â€” <cite>[Ysenia Perez-Cruz](https://speakerdeck.com/yeseniaperezcruz/building-flexible-design-systems)</cite>

I've been working on some data visualization components in a design system, let's use this as an example (don't judge the design of this, it is just an example):

<Graph />

Depending on how we structured and named the APIs for this component, it could either be semantic or presentational. A presentational version might look like this:

```java
public interface DataVisualization {
  private static String rightHeader;
  private static String leftHeader;
  private static String footerButton;
  private static String footerText;
  private static DataSet dataSet;
}
```

This component interface is presentational because the API is based on how it *looks* rather than what it *does*. This makes the component very brittle and rigid. I can't change where the `footerText` is displayed without breaking what it means to people using the component. I could instead write the interface like this:

```java
public interface DataVisualization {
  private static String title;
  private static String subTitle;
  private static String action;
  private static String metaData;
  private static DataSet dataSet;
}
```

This now describes what each part does, rather than how it might be implemented visually. This allows the component owner to make visual updates, like changing the implementation, without breaking the API. Now we are free to change where the `metaData` is presented, maybe we move it above the graph. If it were called `footerText` this attribute name would no longer make sense. For example we could update the component to look like this without breaking the meaning of it:

<Graphv2 />

This also has the added bonus of being more localizable. For right-to-left languages attributes like `leftHeader` and `rightHeader` don't make sense. If you really wanted to make the component API based on layout, a more localized version would be `startHeader` and `endHeader`, or something similar.

#### Component naming

Similar to how the component API should be based on its scenario or use case, the name of the component itself should reflect the use case of the component rather than how it looks. A presentationally named component cannot change how it looks without breaking what the user expects the component to do. One example is:

* **Horizontal Scrolling Tiles**: This component name is presentational; it describes how the component looks. You know when you use this component, it will be tiles arranged horizontally that scrolls.
* **Key Data Points**: This is the same component, but named based on the use case. It is meant to display key data points. They could be displayed in horizontal tiles, or maybe they are displayed in a bar or some other cool way I don't even know.

Thinking about the scenario and the semantics of the component before doing any design or development work is important to get right from the start. The component name and API is a contract to the user, that this component will do what it says. 